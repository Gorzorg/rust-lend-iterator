use std::marker::PhantomData;
use std::ops::Deref;

use std::collections::*;

/// If a type `C` is a collection, and if `C` implements `LendIterator`,
/// then any instance of `C` with lifetime `'a` can create an iterator that yields
/// references with any lifetime `'i` such that `'a : 'i` to the elements of the collection,
/// without consuming the collection as `into_iter` would.
///
/// The function that creates the iterator is called `lend_iter`.
///
/// This trait is implemented for the collections implemented by the standard library,
/// and for those collections `lend_iter` in most cases amounts to the following:
///
/// ``` text
/// fn lend_iter<'a: 'i, 'i>(&'a self) -> Self::LendIter<'i>
/// {
///     self.iter()
/// }
/// ```
///
/// The `ImplVariant` generic for this trait is a way to avoid the "Conflicting implementation"
/// errors from the Rust compiler, and also a way to allow one to implement the borrow iterator
/// in many different ways in the same collection.
pub trait LendIterator<'a, const IMPL_VAR: u32 = 0>: 'a {
    type LendIter<'i>: Iterator<Item = &'i Self::Item>
    where
        'a: 'i;
    type Item: 'a + ?Sized;
    fn lend_iter<'i>(&'a self) -> Self::LendIter<'i>
    where
        'a: 'i;
}

/// This trait is basically the same as `LendIterator`, with the difference that
/// if a collection implements `LendIteratorMut`, the iterator generated from
/// `lend_iter_mut` yields `&mut Item` objects instead of `& Item` objects.
///
/// The function `lend_iter_mut` is not declared in `LendIterator` itself because
/// some collections may only be able to implement `lend_iter`
///
/// The other difference is that this trait has two distinct associated types
/// that determine the item type returned by the iterator.
/// This is because some collections (e.g. maps) need to return data that is only
/// partly mutable.  
pub trait LendIteratorMut<'a, const IMPL_VAR: u32 = 0>: 'a {
    type LendIterMut<'i>: Iterator<Item = (Option<&'i Self::ItemImmut>, &'i mut Self::ItemMut)>
    where
        'a: 'i;
    type ItemImmut: 'a + ?Sized;
    type ItemMut: 'a + ?Sized;
    fn lend_iter_mut<'i>(&'a mut self) -> Self::LendIterMut<'i>
    where
        'a: 'i;
}

/// To be used as `LendIteratorMut::ItemImmut` if the immutable part of the data
/// generated by the mutable iterator does not exist.
pub enum Nothing {}

/// A struct whose purpose is to adapt already existing iterators that yield
/// mutable references for use in `LendIteratorMut`
pub struct IterMutAdapter<'i, Iter: Iterator> {
    iter: Iter,
    p: PhantomData<&'i ()>,
}

impl<'i, Iter: Iterator> Iterator for IterMutAdapter<'i, Iter> {
    type Item = (Option<&'i Nothing>, <Iter as Iterator>::Item);
    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next().map(|x| (None, x))
    }
}

/// Implements the trait `LendIterator` for the types for which the implementation
/// basically amounts to forwarding an already existing `.iter` method.
///
/// The lifetimes `'a`, `'i`, and the bound `'a: 'i`, are hardcoded, which allows one to omit them
/// to some extent in the macro input
macro_rules! implement_basic {
    ($(
        [$($additional_impl_generics: tt)*]
        $type: ty,
        $iter_type: ty, $item_type: ty
        $(, $iter_mut_type: ty, $item_mut_type: ty)?
    );+ $(;)?) => {
        $(
            impl<'a, $($additional_impl_generics)*> LendIterator<'a> for $type {
                type LendIter<'i> = $iter_type
                where
                    'a: 'i;
                type Item = $item_type;
                #[inline]
                fn lend_iter<'i>(&'a self) -> Self::LendIter<'i>
                where 'a: 'i
                {
                    self.iter()
                }
            }

            implement_basic_mut!(
                [$($additional_impl_generics)*] $type
                $(, $iter_mut_type, $item_mut_type)?
            );
        )+
    };
}

macro_rules! implement_basic_mut {
    ([$($additional_impl_generics: tt)*] $type: ty) => {};
    ([$($additional_impl_generics: tt)*] $type: ty, $iter_mut_type: ty, $item_mut_type: ty) => {
        impl<'a, $($additional_impl_generics)*> LendIteratorMut<'a> for $type {
            type LendIterMut<'i> = IterMutAdapter<'i, $iter_mut_type>
            where
                'a: 'i;
            type ItemImmut = Nothing;
            type ItemMut = $item_mut_type;
            #[inline]
            fn lend_iter_mut<'i>(&'a mut self) -> Self::LendIterMut<'i>
            where 'a: 'i
            {
                IterMutAdapter{iter: self.iter_mut(), p: PhantomData}
            }
        }
    }
}

implement_basic!(
    [T: 'a, const N: usize] [T; N], core::slice::Iter<'i, T>, T, core::slice::IterMut<'i, T>, T;
    [T: 'a] [T], core::slice::Iter<'i, T>, T, core::slice::IterMut<'i, T>, T;
    [T: 'a] std::vec::Vec<T>, core::slice::Iter<'i, T>, T, core::slice::IterMut<'i, T>, T;
    [T: 'a] VecDeque<T>, vec_deque::Iter<'i, T>, T, vec_deque::IterMut<'i, T>, T;
    [T: 'a] LinkedList<T>, linked_list::Iter<'i, T>, T, linked_list::IterMut<'i, T>, T;
    [T: 'a] BinaryHeap<T>, binary_heap::Iter<'i, T>, T;
    [K: 'a] BTreeSet<K>, btree_set::Iter<'i, K>, K;
    [K: 'a] HashSet<K>, hash_set::Iter<'i, K>, K;
);

/// A struct that helps implementing `LendIterator` and `LendIteratorMut`
/// for map types. It performs the `unsafe` logic in a standard way,
/// so that it is easier to implement the trait for different map types
/// without having to introduce multiple points of failure in the
/// soundness of the programs that use these traits.
pub struct MapLendIter<'a, MapIter: Iterator, Item, const MUT: bool> {
    iterator: MapIter,
    last_item: Option<Item>,
    p: PhantomData<&'a ()>,
}

impl<'a, MapIter: Iterator, Item, const MUT: bool> MapLendIter<'a, MapIter, Item, MUT> {
    #[inline]
    fn new(iterator: MapIter) -> Self {
        Self {
            iterator,
            last_item: None,
            p: Default::default(),
        }
    }
}

impl<'a, 'i, K, V, MapIter> Iterator for MapLendIter<'a, MapIter, (&'i K, &'i V), false>
where
    'a: 'i,
    K: 'a,
    V: 'a,
    MapIter: Iterator<Item = (&'i K, &'i V)>,
{
    type Item = &'i (&'a K, &'a V);
    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        self.last_item = self.iterator.next();
        self.last_item.as_ref().map(|x| unsafe {
            // This transmute extends the lifetimes of the &'i K and &'i V
            // pointers to 'a.
            // This is safe because we know that, even though `MapLendIter`
            // only lives `'i` long, the types `K` and `V` live `'a`.
            //
            // This kind of unsafe operation seems unavoidable: for example
            // also the implementation of `Iterator` for `btree_map::Iter`
            // resorts to similar tricks under the hood.
            core::mem::transmute::<&(&K, &V), &'i (&'a K, &'a V)>(x)
        })
    }
}

impl<'a, 'i, K, V, MapIter> Iterator for MapLendIter<'a, MapIter, (Option<&'i K>, &'i mut V), true>
where
    'a: 'i,
    K: 'a,
    V: 'a,
    MapIter: Iterator<Item = (&'i K, &'i mut V)>,
{
    type Item = (Option<&'i K>, &'i mut V);
    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        self.last_item = self.iterator.next().map(|(k, v)| (Some(k), v));
        self.last_item.take().map(|x| unsafe {
            // This transmute extends the lifetimes of the &'i K and &'i V
            // pointers to 'a.
            // This is safe because we know that, even though `MapLendIter`
            // only lives `'i` long, the types `K` and `V` live `'a`.
            //
            // This kind of unsafe operation seems unavoidable: for example
            // also the implementation of `Iterator` for `btree_map::Iter`
            // resorts to similar tricks under the hood.
            core::mem::transmute::<(Option<&K>, &mut V), (Option<&'a K>, &'a mut V)>(x)
        })
    }
}

/// Implements `LendIterator` and `LendIteratorMut` for map types that are already
/// equipped with `iter` and an `iter_mut` methods.
macro_rules! implement_map {
    ([$(additional_generics: tt)*] $map_type: ty, $iter_type: ty, $iter_mut_type: ty) => {
        impl<'a, K: 'a, V: 'a> LendIterator<'a> for $map_type {
            type Item = (&'a K, &'a V);
            type LendIter<'i> = MapLendIter<'a, $iter_type, (&'i K, &'i V), false>
            where
                'a: 'i;
            #[inline]
            fn lend_iter<'i>(&'a self) -> Self::LendIter<'i>
            where
                'a: 'i,
            {
                MapLendIter::new(self.iter())
            }
        }

        impl<'a, K: 'a, V: 'a> LendIteratorMut<'a> for $map_type {
            type ItemImmut = K;
            type ItemMut = V;
            type LendIterMut<'i> = MapLendIter<'a, $iter_mut_type, (Option<&'i K>, &'i mut V), true>
            where
                'a: 'i;
            #[inline]
            fn lend_iter_mut<'i>(&'a mut self) -> Self::LendIterMut<'i>
            where
                'a: 'i,
            {
                MapLendIter::new(self.iter_mut())
            }
        }
    };
}

implement_map!([] BTreeMap<K, V>, btree_map::Iter<'i, K, V>, btree_map::IterMut<'i, K, V>);
implement_map!([] HashMap<K, V>, hash_map::Iter<'i, K, V>, hash_map::IterMut<'i, K, V>);

// Here we set the `ImplVariant` generic parameter to 1 in order to avoid
// a conflicting implementation error:
// If any `Deref` implementation is added to the standard library in the future for any
// of the collections we already implemented `LendIterator` for, then the implementation
// is just added to the side of the already existing one instead of causing a conflict.
//
// The conflict of implementation would realistically never arise, since it would require
// an iterable object for which `LendIterator` is implemented
// to also implement Deref to a type that implements `LendIterator`.
// This unlikely combination is nonetheless possible, which implies the need for
// a redundant generic argument in the trait.
impl<'a, D, T> LendIterator<'a, 1> for D
where
    D: 'a + Deref<Target = T>,
    T: LendIterator<'a, 0>,
{
    type LendIter<'i> = T::LendIter<'i>
    where 'a: 'i;
    type Item = T::Item;
    fn lend_iter<'i>(&'a self) -> Self::LendIter<'i>
    where
        'a: 'i,
    {
        self.deref().lend_iter()
    }
}

/// We test the lend_iter functionality
#[test]
fn test_lend_iterator() {
    let v = vec![1, 2, 3, 4];
    let mut w = v.lend_iter().map(|x| x.clone()).collect::<Vec<_>>();
    for (x, y) in v.lend_iter().zip(w.lend_iter()) {
        assert!(x == y);
    }
    let a1 = v.lend_iter();
    let mut a2 = v.lend_iter();
    for (index, x) in a1.enumerate() {
        w.push(x.clone());
        if index % 2 == 0 {
            if let Some(y) = a2.next() {
                w.push(y.clone());
            }
        }
    }
    let a3 = v.lend_iter();
    for (index, x) in a3.enumerate() {
        w.push(x.clone());
        if index % 2 == 0 {
            if let Some(y) = a2.next() {
                w.push(y.clone());
            }
        }
    }

    let t = vec![1, 2, 3, 4, 1, 1, 2, 3, 2, 4, 1, 3, 2, 3, 4, 4];
    for (x, y) in t.lend_iter().zip(w.lend_iter()) {
        assert!(x == y);
    }
}

/// This test should not compile.
/// It is in doctest format, because doctests allow
/// to set the `compile_fail` flag that signals that the code
/// being tested should fail to compile
///
/// In this test, the reason for failure is that `v`
/// does not live long enough to make `m.get(&1)` a safe operation.
/// ```compile_fail
/// use lazy_concatenation::LendIterator;
/// let mut m = std::collections::BTreeMap::new();
/// {
///     let v = vec![1, 2, 3];
///     m.insert(1, v.lend_iter());
/// }
/// let _k = m.get_mut(&1);
/// ```
fn _test_invalid_lifetime() {}

/// This test should not compile.
/// It is in doctest format, because doctests allow
/// to set the `compile_fail` flag that signals that the code
/// being tested should fail to compile
///
/// This test aims at testing if the `transmute` operations used in
/// the construction of the map's lend iterator, that extend the
/// lifetime of the references, are actually sound.
///
/// Towards that goal, we try writing some code that lend-iterates
/// over a map, that saves a reference to one of the values in the map,
/// and that, after the lend-iterator has been destroyed, tries
/// deallocating the value before using it.
///
/// In this test, the reason for failure is that `r` stores
/// a value that was copied from `k`, that is an item returned
/// by `m.lend_iter()`, and therefore counts as a
/// borrow of `m` while it is alive. By calling `m.clear()`, and
/// later trying to print `r`, we are extending the lifetime of
/// the borrow until after `m.clear()` is called. Since `clear`
/// requires a mutable borrow of `m`, the code does not compile.
///
/// Very similar code would show that also `lend_iter_mut` is safe
/// in the same circumstances.
///
/// ```compile_fail
/// use lazy_concatenation::LendIterator;
/// let mut m = std::collections::BTreeMap::new();
/// m.insert(1, 2);
/// let mut r = None;
/// for (k, _v) in m.lend_iter() {
///     r = Some(*k);
/// }
///
/// assert_eq!(r.unwrap(), &1);
///
/// m.clear();
///
/// println!("{}", r.unwrap());
/// ```
fn _test_map_lend_iter_invalid_double_borrow() {}

/// This test should not compile.
/// It is in doctest format, because doctests allow
/// to set the `compile_fail` flag that signals that the code
/// being tested should fail to compile
///
/// This test aims at testing if the `transmute` operations used in
/// the construction of the map's lend iterator, that extend the
/// lifetime of the references, are actually sound.
///
/// Towards that goal, we try writing some code that lend-iterates
/// over a map, that saves a reference to one of the values in the map,
/// and that, after the lend-iterator has been destroyed, tries
/// creating another reference to the same value.
///
/// ```compile_fail
/// use lazy_concatenation::LendIterator;
/// let mut m = std::collections::BTreeMap::new();
/// m.insert(1, 2);
/// let mut r = m.lend_iter_mut().next().map(|(_, v)| v).unwrap();
/// assert_eq!(r, m.get(&1));
/// ```
fn _test_map_lend_iter_invalid_double_borrow_2() {}

#[test]
fn map_lend_iter_mut_valid_double_borrow() {
    let mut m = BTreeMap::new();
    m.insert(1, 2);
    m.insert(3, 4);
    // We can successfully create many &mut references to parts of `m`
    // as long as they reference disjoint data. Analogous to
    // `slice::split_at_mut`.
    let mut r = vec![];
    for (_k, v) in m.lend_iter_mut() {
        r.push(v);
    }
    // I know that Vec already implements swap. This function is here
    // only for demo purposes, to make clear what is going on in the
    // borrow checker.
    fn swap(a: &mut i32, b: &mut i32) {
        let tmp = *a;
        *a = *b;
        *b = tmp;
    }
    // Here we use the aforementioned `slice::split_at_mut` to be actually
    // able to access two disjoint mutable borrows of `r`, which are in turn
    // two disjoint mutable borrows of `m`.
    let (a, b) = r.split_at_mut(1);
    swap(a[0], b[0]);

    assert_eq!(m.get(&1).unwrap(), &4);
    assert_eq!(m.get(&3).unwrap(), &2);
}
